using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;
using System.Xml.Serialization;
using Microsoft.CSharp;
using System.CodeDom.Compiler;
using Eco.Extensions;
using Eco.Attributes;

namespace Eco.Serialization
{
	static class SerializableTypeEmitter
	{
		public static Type GetSerializableTypeFor<T>(ISerializationAttributesGenerator attributesGenerator, Usage defaultUsage)
		{
			Func<FieldInfo, Type> MapFieldType = field =>
			{
				var fieldType = field.FieldType;
				if (field.IsDefined(typeof(RefAttribute)) ||
					field.IsDefined(typeof(ConverterAttribute)) ||
					Nullable.GetUnderlyingType(fieldType).IsSimple())
				{
					return typeof(string);
				}
				else
				{
					return fieldType;
				}
			};
			return Emit(typeof(T), attributesGenerator, MapFieldType, defaultUsage);
		}

		public static Type GetSchemaTypeFor<T>(ISerializationAttributesGenerator attributesGenerator, Usage defaultUsage)
		{
			Func<FieldInfo, Type> MapFieldType = field =>
			{
				var fieldType = field.FieldType;
				if (field.IsDefined(typeof(RefAttribute)) || field.IsDefined(typeof(ConverterAttribute)))
				{
					return typeof(string);
				}
				else if (Nullable.GetUnderlyingType(fieldType).IsSimple())
				{
					return Nullable.GetUnderlyingType(fieldType);
				}
				else
				{
					return fieldType;
				}
			};
			return Emit(typeof(T), attributesGenerator, MapFieldType, defaultUsage);
		}

		static Type Emit(Type rootSettingsType, ISerializationAttributesGenerator attributesGenerator, Func<FieldInfo, Type> MapFieldType, Usage defaultUsage)
		{
			string compilationUnit = GenerateClassDefinitionRecursevely(rootSettingsType, attributesGenerator, MapFieldType, defaultUsage);
			string[] referencedAssemblies = AppDomain.CurrentDomain.GetAssemblies()
				.Where(a => !a.IsDynamic)
				.Select(a => a.Location)
				.ToArray();
			CompilerParameters p = new CompilerParameters(referencedAssemblies);
			CompilerResults results = new CSharpCodeProvider().CompileAssemblyFromSource(p, compilationUnit);
			if (results.Errors.Count > 0) throw new ApplicationException(String.Format("Could not emit xml serialization classes for the '{0}' settings type", rootSettingsType.Name));
			return results.CompiledAssembly.GetTypes().First(t => t.Name == rootSettingsType.Name);
		}

		public static string GenerateClassDefinitionRecursevely(Type root, ISerializationAttributesGenerator attributesGenerator, Func<FieldInfo, Type> MapFieldType, Usage defaultUsage)
		{
			var autogenNamespace = root.Namespace + ".AutoGenerated";
			var codeBuilder = new CompilationUnitBuilder(autogenNamespace);
			codeBuilder.AddAssemblyAttribute(typeof(SettingsAssemblyAttribute).FullName);
			foreach (var type in root.GetReferencedSettingsTypesRecursive())
			{
				string baseTypeName = type.BaseType.IsSettingsType() ? type.BaseType.GetFriendlyName(autogenNamespace) : null;
				var classBuilder = codeBuilder.AddClass(type.Name, baseTypeName);
				classBuilder.AddAttributes(attributesGenerator.GetAttributesTextFor(type, isRoot: type == root));
				foreach (var field in type.GetFields())
				{
					var serializableFieldType = MapFieldType(field);
					var fieldBuilder = classBuilder.AddField(GetFullTypeName(autogenNamespace, serializableFieldType), field.Name);
					fieldBuilder.AddAttributes(attributesGenerator.GetAttributesTextFor(autogenNamespace, field, defaultUsage));
				}
			}
			return codeBuilder.ToString();
		}

		static string GetFullTypeName(string autogenNamespace, Type type)
		{
			if (type.IsSettingsType() || type.IsSettingsArrayType()) return type.GetFriendlyName(autogenNamespace);
			else return type.GetFriendlyName(type.Namespace);
		}
	}
}
